# 08 - Enterprise SEO & Edge Architecture

## 1. Core Strategy: "Materialized HTML" (Hybrid SSG)
To achieve 100% indexability and sub-second load times while maintaining a dynamic React architecture, we use a **Materialized HTML** pattern. This effectively turns our dynamic CMS into a **Static Site Generator (SSG)** on demand.

### The Problem
Traditional SPAs serve an empty `<div>` and rely on client-side JS to render content. This causes:
1.  **Poor SEO**: Bots see "Thin Content" or fail to index deep links.
2.  **MIME Type Errors**: Deep URLs (e.g., `/category/tech/ai`) break relative asset paths.
3.  **Hydration Errors**: React crashes (Error #418/#423) when the server HTML doesn't perfectly match the client render.

### The Solution: "Publish-Time Materialization"
Instead of generating HTML *when a user visits* (Server-Side Rendering / SSR), we generate it **once** when the editor clicks "Publish".

### The Flow
1.  **Editor Publishes Post:**
    * Backend saves data to MariaDB.
    * Backend triggers `HtmlMaterializerService` (Async).
    * Service fetches the **Live React Shell** (`index.html`) from the internal Nginx gateway.
    * Service injects:
        * SEO Title & Meta Tags.
        * JSON-LD Schema (Google News compliant).
        * **Full HTML Body Content** (into `<div id="server-content">`).
        * **Redux State** (into `window.__PRELOADED_STATE__`).
    * Service uploads the resulting `.html` file to MinIO (bucket: `treish-public`) under `posts/{slug}.html`.

2.  **Cloudflare Worker (The Router):**
    * Intercepts requests to `/category/...`.
    * Implements a **Cache-First Strategy**:
        * **Strategy A (Static Hit):** Checks MinIO (via Nginx) for `posts/{slug}.html`.
            * **CRITICAL:** Injects `<base href="/">` into the `<head>`. This forces the browser to load CSS/JS from the root domain, preventing MIME type errors on deep URLs.
        * **Strategy B (Fallback):** If missing (or Backend down), falls back to fetching API JSON and injecting it into the empty shell (Edge Hydration).

3.  **Client (Browser/Googlebot):**
    * **Googlebot:** Sees fully rendered HTML immediately (`<body>...content...</body>`).
    * **User:** Sees content immediately (FCP < 0.5s).
    * **React:** Detects `window.__PRELOADED_STATE__`, builds the interactive app in `<div id="root">`, and **removes** the static `<div id="server-content">` to prevent duplication.

---

## 2. Technical Implementation

### Backend (Java/Spring Boot)
* **Service:** `HtmlMaterializerService.java`
* **Trigger:** `BlogPostServiceImpl.save()` (on Publish/Update).
* **Serialization Fix:** Manually serializes `Instant` fields to Strings to prevent Jackson configuration crashes (HTTP 500).
* **Storage Path:** Uploads to `posts/{userFriendlySlug}.html` in MinIO.

### Edge (Cloudflare Worker)
* **Smart Routing:**
    * Parses URL to extract the `slug`.
    * **Path:** Requests `/api/uploads/posts/{slug}.html` (Direct Nginx Static Asset path, bypassing Spring Boot `/v1` API).
    * **Headers:** Adds `X-Source: Materialized-HTML` on success.
* **Asset Integrity:** The `<base href="/">` injection is performed using `HTMLRewriter`. This is mandatory for the "Plain Text" fix.

### Frontend (React)
* **Root Strategy:** We use `ReactDOM.createRoot` (Client-Side Rendering) instead of `hydrateRoot`.
    * **Why:** `hydrateRoot` expects the DOM to match perfectly. Since we inject SEO content into a separate container (`#server-content`) while React builds in `#root`, using `hydrateRoot` causes React Errors #418 & #423.
    * **Performance:** With `window.__PRELOADED_STATE__`, `createRoot` renders instantly without fetching data, mimicking the speed of hydration without the fragility.
* **Cleanup Logic (`SinglePostPage.js`):**
    ```javascript
    useEffect(() => {
        // Immediately remove the static SEO content to avoid "Double Content"
        const serverContent = document.getElementById('server-content');
        if (serverContent) serverContent.remove();
        
        // Hydrate state
        if (window.__PRELOADED_STATE__) { ... }
    }, []);
    ```

---

## 3. Robots & Sitemap
* **Robots.txt:** Managed by Cloudflare Worker (dynamic).
* **Sitemaps:** Generated by Backend (`SitemapService`), proxied by Cloudflare Worker to avoid CORS issues and expose them at the root (`/sitemap.xml`).

## 4. Verification & Debugging

**Script:** `scripts/verify_seo.sh <slug>`

**Checks Performed:**
1.  **MinIO Check:** Verifies the `.html` file exists in the public bucket.
2.  **Worker Check:** Curls the public URL with `User-Agent: Googlebot`.
3.  **Header Check:** Confirms `X-Source: Materialized-HTML`.
4.  **Base Tag Check:** Confirms `<base href="/">` is present (preventing broken styles).

**Example Output:**
```bash
$ ./verify_seo.sh market-rally-2025
1. Checking HTML File generation... SUCCESS (200 OK)
2. Checking Cloudflare Worker routing... SUCCESS (Served Pre-rendered HTML)
3. Checking Base Tag Injection... SUCCESS (Base Tag Found)
4. Checking React State... SUCCESS (State Injected)